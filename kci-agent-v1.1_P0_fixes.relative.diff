--- a/src/agents/index_agent.py
+++ b/src/agents/index_agent.py
@@ -87,7 +87,8 @@
                     total_weight += weight
             
             if total_weight > 0:
-                kci_values.append(weighted_sum / total_weight * total_weight)  # 정규화
+                # P0 Fix: 가중평균으로 정규화(결측이 생겨도 total_weight로 재정규화)
+                kci_values.append(weighted_sum / total_weight)
             else:
                 kci_values.append(np.nan)
         

--- /dev/null
+++ b/data/processed/menu_snapshot.json
@@ -0,0 +1,4 @@
+{
+  "updated_at": null,
+  "menus_by_brand": {}
+}

--- a/src/gates/data_quality.py
+++ b/src/gates/data_quality.py
@@ -11,11 +11,13 @@
 
 import pandas as pd
 import numpy as np
+import json
+from pathlib import Path
 from datetime import datetime
 from typing import Optional
 from loguru import logger
 
-from src.config import DATA_QUALITY_CONFIG, BRAND_CONFIGS
+from src.config import DATA_QUALITY_CONFIG, BRAND_CONFIGS, get_settings, COLLECTION_DAY
 from src.state import (
     DataQualityReport, 
     SourceConsistency, 
@@ -31,7 +33,37 @@
     
     def __init__(self, config=None):
         self.config = config or DATA_QUALITY_CONFIG
-        self._previous_menu_hashes = {}  # 메뉴 변경 감지용
+
+        # P0 Fix: 실행 간 표본(메뉴) 변경 감지를 위해 스냅샷을 디스크에 저장
+        settings = get_settings()
+        self._menu_snapshot_path = (
+            Path(settings.project_root) / "data" / "processed" / "menu_snapshot.json"
+        )
+        self._previous_menu_snapshot = self._load_menu_snapshot()
+
+    def _load_menu_snapshot(self) -> dict:
+        """이전 실행의 메뉴 스냅샷 로드 (brand -> sorted menus)"""
+        try:
+            if self._menu_snapshot_path.exists():
+                with open(self._menu_snapshot_path, "r", encoding="utf-8") as f:
+                    payload = json.load(f)
+                return payload.get("menus_by_brand", {})
+        except Exception as e:
+            logger.warning(f"menu_snapshot 로드 실패: {e}")
+        return {}
+
+    def _save_menu_snapshot(self, menus_by_brand: dict) -> None:
+        """메뉴 스냅샷 저장"""
+        try:
+            self._menu_snapshot_path.parent.mkdir(parents=True, exist_ok=True)
+            payload = {
+                "updated_at": datetime.now().isoformat(),
+                "menus_by_brand": menus_by_brand,
+            }
+            with open(self._menu_snapshot_path, "w", encoding="utf-8") as f:
+                json.dump(payload, f, ensure_ascii=False, indent=2)
+        except Exception as e:
+            logger.warning(f"menu_snapshot 저장 실패: {e}")
     
     def validate(
         self,
@@ -141,18 +173,42 @@
         return len(errors) == 0, errors
     
     def _calculate_missing_rate(self, df: pd.DataFrame) -> dict[str, float]:
-        """브랜드별 결측률 계산"""
-        if "brand" not in df.columns:
+        """브랜드별 결측률 계산 ("행 누락"까지 포함)
+
+        - 기존: price NaN 비율만 계산 → row 자체가 누락되면 결측률이 과소추정될 수 있음
+        - 개선: 기대 날짜 그리드 대비 (non-null 관측치 / 기대 관측치) 기반 결측률 계산
+        """
+        if "brand" not in df.columns or "date" not in df.columns:
             return {}
-        
-        result = {}
+
+        dfx = df.copy()
+        dfx["date"] = pd.to_datetime(dfx["date"]).dt.normalize()
+
+        unique_dates = pd.DatetimeIndex(sorted(dfx["date"].unique()))
+        if len(unique_dates) == 0:
+            return {b: 1.0 for b in BRAND_CONFIGS.keys()}
+
+        inferred = pd.infer_freq(unique_dates)
+        if inferred is None:
+            # COLLECTION_DAY: 0=월 ... 6=일
+            day_map = {0: "MON", 1: "TUE", 2: "WED", 3: "THU", 4: "FRI", 5: "SAT", 6: "SUN"}
+            inferred = f"W-{day_map.get(COLLECTION_DAY, 'SUN')}"
+
+        expected_dates = pd.date_range(unique_dates.min(), unique_dates.max(), freq=inferred)
+        expected_n = len(expected_dates) if len(expected_dates) > 0 else 1
+
+        result: dict[str, float] = {}
         for brand in BRAND_CONFIGS.keys():
-            brand_data = df[df["brand"] == brand]
-            if len(brand_data) == 0:
-                result[brand] = 1.0  # 데이터 없음 = 100% 결측
-            else:
-                result[brand] = brand_data["price"].isna().mean()
-        
+            brand_rows = dfx[dfx["brand"] == brand]
+            if len(brand_rows) == 0:
+                result[brand] = 1.0
+                continue
+
+            # 동일 날짜에 여러 행이 있으면 평균으로 집계
+            brand_series = brand_rows.groupby("date")["price"].mean().reindex(expected_dates)
+            non_null = int(brand_series.notna().sum())
+            result[brand] = 1.0 - (non_null / expected_n)
+
         return result
     
     def _detect_outliers(self, df: pd.DataFrame) -> list[dict]:
@@ -221,33 +277,35 @@
         return outliers
     
     def _detect_sample_changes(self, df: pd.DataFrame) -> tuple[bool, list[dict]]:
-        """표본 변경 감지 (메뉴/가게 변경)"""
-        changes = []
-        
+        """표본 변경 감지 (메뉴/가게 변경) - 실행 간 비교 가능하도록 영속화"""
+        changes: list[dict] = []
+
         if "brand" not in df.columns or "menu" not in df.columns:
             return False, changes
-        
+
+        prev_snapshot = {k: set(v) for k, v in (self._previous_menu_snapshot or {}).items()}
+        current_snapshot: dict[str, list[str]] = {}
+
         for brand in df["brand"].unique():
             brand_data = df[df["brand"] == brand]
-            current_menus = set(brand_data["menu"].unique())
-            
-            # 이전 기록과 비교
-            prev_menus = self._previous_menu_hashes.get(brand, set())
-            
+            current_menus = set(brand_data["menu"].dropna().astype(str).unique())
+            current_snapshot[brand] = sorted(current_menus)
+
+            prev_menus = prev_snapshot.get(brand, set())
             if prev_menus and current_menus != prev_menus:
-                added = current_menus - prev_menus
-                removed = prev_menus - current_menus
-                
+                added = sorted(list(current_menus - prev_menus))
+                removed = sorted(list(prev_menus - current_menus))
                 if added or removed:
                     changes.append({
                         "brand": brand,
-                        "added_menus": list(added),
-                        "removed_menus": list(removed),
+                        "added_menus": added,
+                        "removed_menus": removed,
                     })
-            
-            # 현재 상태 저장
-            self._previous_menu_hashes[brand] = current_menus
-        
+
+        # 스냅샷 저장 및 상태 갱신
+        self._save_menu_snapshot(current_snapshot)
+        self._previous_menu_snapshot = current_snapshot
+
         return len(changes) > 0, changes
     
     def _check_source_consistency(

--- a/src/agents/backtest_agent.py
+++ b/src/agents/backtest_agent.py
@@ -52,8 +52,8 @@
         신호 생성 (Look-ahead bias 방지)
         
         Entry 조건:
-        - 주간 변화율 > threshold
-        - 20MA 상향 돌파
+        - "주간" 변화율 > threshold (데이터 주기가 주간이면 1 period, 일간이면 5 period)
+        - MA 상향 돌파
         """
         signals = pd.Series(0, index=kci.index)
         ma_period = self.config.ma_period
@@ -62,70 +62,101 @@
             logger.warning(f"데이터 부족: {len(kci)} < {ma_period + 5}")
             return signals
         
+        freq = pd.infer_freq(pd.DatetimeIndex(kci.index))
+        # 주간이면 1주 변화, 일간이면 5영업일 변화로 근사
+        change_lookback = 1
+        if freq and freq.startswith("D"):
+            change_lookback = 5
+        elif freq and freq.startswith("W"):
+            change_lookback = 1
+        elif freq and freq.startswith("M"):
+            change_lookback = 1
+        
         for t in range(ma_period + 1, len(kci)):
             # t 시점에서는 t-1까지의 데이터만 사용 가능
             available = kci.iloc[:t]
-            
-            if len(available) < 5:
+            if len(available) < change_lookback + 2:
                 continue
             
-            # 조건 1: 변화율
-            recent_change = available.iloc[-1] / available.iloc[-5] - 1
+            # 조건 1: 변화율 (lookback)
+            recent_change = available.iloc[-1] / available.iloc[-(change_lookback + 1)] - 1
             
             # 조건 2: MA 상향 돌파
             current_ma = available.iloc[-ma_period:].mean()
-            prev_ma = available.iloc[-(ma_period+1):-1].mean()
-            
+            prev_ma = available.iloc[-(ma_period + 1):-1].mean()
             price_above_ma = available.iloc[-1] > current_ma
             was_below_ma = available.iloc[-2] <= prev_ma
             
-            if (recent_change > self.config.weekly_change_threshold and 
+            if (recent_change > self.config.weekly_change_threshold and
                 price_above_ma and was_below_ma):
                 signals.iloc[t] = 1
         
         logger.info(f"신호 생성 완료: {(signals == 1).sum()}개 진입 신호")
         return signals
-    
+
     def execute_backtest(
         self,
         kci: pd.Series,
         signals: pd.Series,
         prices: pd.Series,
     ) -> dict:
-        """백테스트 실행"""
-        trades = []
+        """백테스트 실행
+        
+        Returns:
+            dict: {trades, returns, equity_curve}
+        """
+        trades: list[TradeRecord] = []
+        
+        # 정렬/정합성
+        prices = prices.reindex(kci.index).ffill().bfill()
+        signals = signals.reindex(kci.index).fillna(0).astype(int)
+        
+        # 실행 지연(기본 1 period): signal(t) → execute(t+delay)로 처리
+        exec_signals = signals.shift(self.config.execution_delay).fillna(0).astype(int)
+        
+        equity = 1.0
+        cash = 1.0
+        shares = 0.0
         position = 0
         entry_price = 0.0
         entry_date = None
-        daily_returns = []
         
-        for t in range(1, len(signals)):
-            signal = signals.iloc[t-1]
-            today = signals.index[t]
-            today_price = prices.iloc[t] if t < len(prices) else prices.iloc[-1]
-            
-            # 진입
-            if signal == 1 and position == 0:
-                entry_price = today_price * (1 + self.config.slippage) * (1 + self.config.commission)
-                entry_date = today
-                position = 1
-                logger.debug(f"진입: {today} @ {entry_price:.0f}")
-            
-            # 포지션 보유 중
-            if position == 1:
+        equity_curve = []
+        returns = []
+        prev_equity = equity
+        
+        for t, today in enumerate(kci.index):
+            price = float(prices.loc[today])
+            signal_today = int(exec_signals.loc[today])
+            
+            # ===== 진입 (오늘 체결) =====
+            if signal_today == 1 and position == 0:
+                invest = self.config.position_size * cash
+                fill_price = price * (1 + self.config.slippage) * (1 + self.config.commission)
+                if fill_price > 0 and invest > 0:
+                    shares = invest / fill_price
+                    cash = cash - invest
+                    entry_price = fill_price
+                    entry_date = today
+                    position = 1
+                    logger.debug(f"진입: {today} @ {entry_price:.0f} (shares={shares:.6f})")
+            
+            # ===== 포지션 보유/청산 판단 =====
+            exit_reason = None
+            if position == 1 and entry_date is not None:
                 holding_days = (today - entry_date).days
-                current_return = today_price / entry_price - 1
-                daily_returns.append(current_return / max(holding_days, 1))
+                current_return = price / entry_price - 1 if entry_price > 0 else 0.0
                 
-                exit_reason = None
                 if holding_days >= self.config.holding_days:
                     exit_reason = "time_limit"
                 if current_return <= self.config.stop_loss:
                     exit_reason = "stop_loss"
                 
                 if exit_reason:
-                    exit_price = today_price * (1 - self.config.slippage) * (1 - self.config.commission)
-                    trade_return = exit_price / entry_price - 1
+                    exit_price = price * (1 - self.config.slippage) * (1 - self.config.commission)
+                    proceeds = shares * exit_price
+                    cash = cash + proceeds
+                    trade_return = (exit_price / entry_price - 1) if entry_price > 0 else 0.0
                     
                     trades.append(TradeRecord(
                         entry_date=entry_date.strftime("%Y-%m-%d"),
@@ -138,52 +169,78 @@
                     ))
                     
                     logger.debug(f"청산: {today} ({exit_reason}), 수익: {trade_return:.2%}")
+                    # reset
+                    shares = 0.0
                     position = 0
+                    entry_price = 0.0
+                    entry_date = None
+            
+            # ===== 포트폴리오 가치 (마크투마켓) =====
+            equity = cash + shares * price
+            equity_curve.append(equity)
+            
+            if t == 0:
+                returns.append(0.0)
+            else:
+                r = (equity / prev_equity - 1) if prev_equity > 0 else 0.0
+                returns.append(r)
+            prev_equity = equity
         
-        return {"trades": trades, "daily_returns": daily_returns}
-    
+        equity_curve = pd.Series(equity_curve, index=kci.index, name="equity")
+        returns = pd.Series(returns, index=kci.index, name="strategy_return")
+        
+        return {"trades": trades, "returns": returns, "equity_curve": equity_curve}
+
     def calculate_metrics(
         self,
         trades: list[TradeRecord],
-        daily_returns: list[float],
+        returns: pd.Series,
+        equity_curve: pd.Series,
         start_date: datetime,
         end_date: datetime,
     ) -> dict:
-        """성과 지표 계산"""
-        if not trades:
-            return {
-                "total_trades": 0, "winning_trades": 0, "losing_trades": 0,
-                "win_rate": 0.0, "total_return": 0.0, "cagr": 0.0,
-                "sharpe_ratio": 0.0, "sortino_ratio": 0.0, "max_drawdown": 0.0,
-                "avg_return": 0.0, "avg_winning_return": 0.0, "avg_losing_return": 0.0,
-                "avg_holding_days": 0.0,
-            }
-        
-        returns = [t["return_pct"] for t in trades]
-        returns_series = pd.Series(returns)
-        winning = [r for r in returns if r > 0]
-        losing = [r for r in returns if r <= 0]
+        """성과 지표 계산 (포트폴리오 기준)"""
+        # 기본값
+        if returns is None or len(returns) < 2:
+            returns = pd.Series([0.0], index=[start_date])
+        if equity_curve is None or len(equity_curve) == 0:
+            equity_curve = pd.Series([1.0], index=[start_date])
         
-        cumulative = (1 + returns_series).cumprod()
-        total_return = cumulative.iloc[-1] - 1 if len(cumulative) > 0 else 0
         years = (end_date - start_date).days / 365
+        total_return = float(equity_curve.iloc[-1] - 1.0)
+        
+        # 주기 추정 → Sharpe/Sortino 스케일링
+        freq = pd.infer_freq(pd.DatetimeIndex(returns.index))
+        if freq and freq.startswith("D"):
+            ppy = 252
+        elif freq and freq.startswith("W"):
+            ppy = 52
+        elif freq and freq.startswith("M"):
+            ppy = 12
+        else:
+            ppy = 52
+        
+        # Trade 통계
+        trade_returns = [t["return_pct"] for t in trades] if trades else []
+        winning = [r for r in trade_returns if r > 0]
+        losing = [r for r in trade_returns if r <= 0]
         
         return {
             "total_trades": len(trades),
             "winning_trades": len(winning),
             "losing_trades": len(losing),
-            "win_rate": len(winning) / len(trades) if trades else 0,
+            "win_rate": len(winning) / len(trades) if trades else 0.0,
             "total_return": total_return,
             "cagr": calculate_cagr(total_return, years),
-            "sharpe_ratio": calculate_sharpe_ratio(returns_series, periods_per_year=12),
-            "sortino_ratio": calculate_sortino_ratio(returns_series, periods_per_year=12),
-            "max_drawdown": calculate_max_drawdown(cumulative),
-            "avg_return": np.mean(returns) if returns else 0,
-            "avg_winning_return": np.mean(winning) if winning else 0,
-            "avg_losing_return": np.mean(losing) if losing else 0,
-            "avg_holding_days": np.mean([t["holding_days"] for t in trades]) if trades else 0,
+            "sharpe_ratio": calculate_sharpe_ratio(returns.dropna(), periods_per_year=ppy),
+            "sortino_ratio": calculate_sortino_ratio(returns.dropna(), periods_per_year=ppy),
+            "max_drawdown": float(calculate_max_drawdown(equity_curve)),
+            "avg_return": float(np.mean(trade_returns)) if trade_returns else 0.0,
+            "avg_winning_return": float(np.mean(winning)) if winning else 0.0,
+            "avg_losing_return": float(np.mean(losing)) if losing else 0.0,
+            "avg_holding_days": float(np.mean([t["holding_days"] for t in trades])) if trades else 0.0,
         }
-    
+
     def identify_failed_cases(self, trades: list[TradeRecord]) -> list[FailedCase]:
         """실패 케이스 식별"""
         return [
@@ -200,19 +257,39 @@
         kci: pd.Series,
         prices: pd.Series,
     ) -> WalkForwardResult:
-        """Walk-forward 검증"""
+        """Walk-forward 검증
+        
+        config는 "months" 단위를 사용하므로, 입력 시계열 주기에 맞춰 period로 변환한다.
+        - Weekly: 1 month ≈ 4 weeks
+        - Daily: 1 month ≈ 21 trading days
+        - Monthly: 1 month = 1 period
+        """
         folds = []
-        total_months = len(kci)
-        in_months = self.config.in_sample_months
-        out_months = self.config.out_sample_months
-        step = self.config.step_months
+        total_periods = len(kci)
+        
+        freq = pd.infer_freq(pd.DatetimeIndex(kci.index))
+        if freq and freq.startswith("D"):
+            per_month = 21
+        elif freq and freq.startswith("W"):
+            per_month = 4
+        elif freq and freq.startswith("M"):
+            per_month = 1
+        else:
+            per_month = 4
+        
+        in_p = int(self.config.in_sample_months * per_month)
+        out_p = int(self.config.out_sample_months * per_month)
+        step_p = int(self.config.step_months * per_month)
+        in_p = max(in_p, 10)
+        out_p = max(out_p, 4)
+        step_p = max(step_p, out_p)
         
         current_start = 0
         fold_num = 1
         
-        while current_start + in_months + out_months <= total_months:
-            train_end = current_start + in_months
-            test_end = train_end + out_months
+        while current_start + in_p + out_p <= total_periods:
+            train_end = current_start + in_p
+            test_end = train_end + out_p
             
             # In-sample
             kci_train = kci.iloc[current_start:train_end]
@@ -220,17 +297,19 @@
             signals_train = self.generate_signals(kci_train)
             train_result = self.execute_backtest(kci_train, signals_train, prices_train)
             train_metrics = self.calculate_metrics(
-                train_result["trades"], train_result["daily_returns"],
+                train_result["trades"], train_result["returns"], train_result["equity_curve"],
                 kci_train.index[0], kci_train.index[-1]
             )
             
             # Out-of-sample
             kci_test = kci.iloc[train_end:test_end]
             prices_test = prices.iloc[train_end:test_end]
-            signals_test = self.generate_signals(kci.iloc[:test_end]).iloc[train_end:test_end]
+            # 신호는 train_end 이전 정보만으로 생성해야 하므로, 전체를 넣고 OOS 구간만 슬라이스
+            signals_full = self.generate_signals(kci.iloc[:test_end])
+            signals_test = signals_full.iloc[train_end:test_end]
             test_result = self.execute_backtest(kci_test, signals_test, prices_test)
             test_metrics = self.calculate_metrics(
-                test_result["trades"], test_result["daily_returns"],
+                test_result["trades"], test_result["returns"], test_result["equity_curve"],
                 kci_test.index[0] if len(kci_test) > 0 else kci_train.index[-1],
                 kci_test.index[-1] if len(kci_test) > 0 else kci_train.index[-1]
             )
@@ -247,15 +326,15 @@
                 degradation=train_metrics["sharpe_ratio"] - test_metrics["sharpe_ratio"],
             ))
             
-            current_start += step
+            current_start += step_p
             fold_num += 1
         
         if folds:
-            avg_oos_sharpe = np.mean([f["test_sharpe"] for f in folds])
-            avg_degradation = np.mean([f["degradation"] for f in folds])
+            avg_oos_sharpe = float(np.mean([f["test_sharpe"] for f in folds]))
+            avg_degradation = float(np.mean([f["degradation"] for f in folds]))
             is_sharpes = [f["train_sharpe"] for f in folds if f["train_sharpe"] != 0]
             oos_sharpes = [f["test_sharpe"] for f in folds]
-            stability = np.mean(oos_sharpes) / np.mean(is_sharpes) if is_sharpes and np.mean(is_sharpes) != 0 else 0
+            stability = float(np.mean(oos_sharpes) / np.mean(is_sharpes)) if is_sharpes and np.mean(is_sharpes) != 0 else 0.0
         else:
             avg_oos_sharpe, avg_degradation, stability = 0.0, 0.0, 0.0
         
@@ -265,33 +344,45 @@
             avg_degradation=avg_degradation,
             stability_score=stability,
         )
-    
+
     def compare_benchmark(
         self,
-        strategy_returns: list[float],
+        strategy_returns: pd.Series,
         benchmark_prices: pd.Series,
         start_date: datetime,
         end_date: datetime,
     ) -> BenchmarkComparison:
-        """벤치마크 대비 성과"""
+        """벤치마크 대비 성과 (포트폴리오 수익률 기준)"""
         years = (end_date - start_date).days / 365
         
-        if strategy_returns:
-            strategy_cumulative = (1 + pd.Series(strategy_returns)).cumprod()
-            strategy_total = strategy_cumulative.iloc[-1] - 1
-            strategy_cagr = calculate_cagr(strategy_total, years)
-            strategy_sharpe = calculate_sharpe_ratio(pd.Series(strategy_returns), periods_per_year=12)
-            strategy_max_dd = calculate_max_drawdown(strategy_cumulative)
+        # 주기 추정
+        freq = pd.infer_freq(pd.DatetimeIndex(strategy_returns.index))
+        if freq and freq.startswith("D"):
+            ppy = 252
+        elif freq and freq.startswith("W"):
+            ppy = 52
+        elif freq and freq.startswith("M"):
+            ppy = 12
         else:
-            strategy_cagr, strategy_sharpe, strategy_max_dd = 0.0, 0.0, 0.0
+            ppy = 52
         
+        # Strategy
+        sr = strategy_returns.dropna()
+        strat_cum = (1 + sr).cumprod()
+        strat_total = float(strat_cum.iloc[-1] - 1) if len(strat_cum) > 0 else 0.0
+        strategy_cagr = calculate_cagr(strat_total, years)
+        strategy_sharpe = calculate_sharpe_ratio(sr, periods_per_year=ppy) if len(sr) > 1 else 0.0
+        strategy_max_dd = float(calculate_max_drawdown(strat_cum)) if len(strat_cum) > 0 else 0.0
+        
+        # Benchmark
+        benchmark_prices = benchmark_prices.reindex(strategy_returns.index).ffill().bfill()
         if len(benchmark_prices) > 1:
-            benchmark_returns = benchmark_prices.pct_change().dropna()
-            benchmark_cumulative = (1 + benchmark_returns).cumprod()
-            benchmark_total = benchmark_cumulative.iloc[-1] - 1 if len(benchmark_cumulative) > 0 else 0
-            benchmark_cagr = calculate_cagr(benchmark_total, years)
-            benchmark_sharpe = calculate_sharpe_ratio(benchmark_returns, periods_per_year=12)
-            benchmark_max_dd = calculate_max_drawdown(benchmark_cumulative)
+            br = benchmark_prices.pct_change().dropna()
+            bench_cum = (1 + br).cumprod()
+            bench_total = float(bench_cum.iloc[-1] - 1) if len(bench_cum) > 0 else 0.0
+            benchmark_cagr = calculate_cagr(bench_total, years)
+            benchmark_sharpe = calculate_sharpe_ratio(br, periods_per_year=ppy) if len(br) > 1 else 0.0
+            benchmark_max_dd = float(calculate_max_drawdown(bench_cum)) if len(bench_cum) > 0 else 0.0
         else:
             benchmark_cagr, benchmark_sharpe, benchmark_max_dd = 0.0, 0.0, 0.0
         
@@ -304,7 +395,7 @@
             strategy_max_dd=strategy_max_dd,
             benchmark_max_dd=benchmark_max_dd,
         )
-    
+
     def run_full_backtest(
         self,
         kci: pd.Series,
@@ -317,24 +408,27 @@
         signals = self.generate_signals(kci)
         result = self.execute_backtest(kci, signals, prices)
         trades = result["trades"]
+        returns = result["returns"]
+        equity_curve = result["equity_curve"]
         
         start_date = kci.index[0]
         end_date = kci.index[-1]
-        metrics = self.calculate_metrics(trades, result["daily_returns"], start_date, end_date)
+        metrics = self.calculate_metrics(trades, returns, equity_curve, start_date, end_date)
         
         failed_cases = self.identify_failed_cases(trades)
-        walk_forward = self.walk_forward_validation(kci, prices)
+        walk_forward = self.walk_forward_validation(kci, prices.reindex(kci.index).ffill().bfill())
         
         if benchmark_prices is None:
             benchmark_prices = prices
+        benchmark_prices = benchmark_prices.reindex(kci.index).ffill().bfill()
         
-        strategy_returns = [t["return_pct"] for t in trades]
-        benchmark_comparison = self.compare_benchmark(strategy_returns, benchmark_prices, start_date, end_date)
+        benchmark_comparison = self.compare_benchmark(returns, benchmark_prices, start_date, end_date)
         
-        # 신뢰구간
-        if strategy_returns:
-            bootstrap_returns = [np.mean(np.random.choice(strategy_returns, len(strategy_returns), replace=True)) for _ in range(1000)]
-            ci_95 = (np.percentile(bootstrap_returns, 2.5), np.percentile(bootstrap_returns, 97.5))
+        # 신뢰구간 (period 수익률 평균의 부트스트랩)
+        if len(returns.dropna()) > 1:
+            r = returns.dropna().values
+            bootstrap_means = [float(np.mean(np.random.choice(r, len(r), replace=True))) for _ in range(1000)]
+            ci_95 = (float(np.percentile(bootstrap_means, 2.5)), float(np.percentile(bootstrap_means, 97.5)))
         else:
             ci_95 = (0.0, 0.0)
         
@@ -361,10 +455,11 @@
             return_ci_95=ci_95,
         )
         
-        logger.info(f"백테스트 완료: {metrics['total_trades']}거래, 승률 {metrics['win_rate']:.1%}, Sharpe {metrics['sharpe_ratio']:.2f}")
+        logger.info(
+            f"백테스트 완료: {metrics['total_trades']}거래, 승률 {metrics['win_rate']:.1%}, Sharpe {metrics['sharpe_ratio']:.2f}"
+        )
         return report
 
-
 class BacktestAgent:
     """백테스트 에이전트 (LangGraph 노드용)"""
     
@@ -374,8 +469,11 @@
     def run(self, state: dict) -> dict:
         """LangGraph 노드 실행"""
         try:
-            kci_data = state.get("kci_monthly") or state.get("kci_weekly")
+            # ===== KCI 입력 (P0 Fix: backtest는 주간 KCI를 기본으로 사용) =====
+            kci_weekly_data = state.get("kci_weekly")
+            kci_monthly_data = state.get("kci_monthly")
             
+            kci_data = kci_weekly_data if kci_weekly_data is not None else kci_monthly_data
             if kci_data is None:
                 return {"error_type": "validation_failed", "error_message": "KCI data is None"}
             
@@ -385,13 +483,41 @@
             else:
                 kci = kci_data
             
-            prices = kci / kci.iloc[0] * 10000
-            report = self.engine.run_full_backtest(kci, prices)
+            # monthly fallback 경고
+            if kci_weekly_data is None and kci_monthly_data is not None:
+                logger.warning("kci_weekly가 없어 kci_monthly로 백테스트를 수행합니다. (전략 파라미터/해석에 주의)")
+            
+            # ===== 타겟 자산 가격 (P0 Fix: KCI를 가격 프록시로 쓰는 것을 기본값에서 제거) =====
+            # state에 target_prices(Series/dict)가 있으면 그걸 사용. 없으면 프록시로 fallback하되 명시적으로 표시
+            price_source = "KCI_PROXY"
+            prices_data = state.get("target_prices") or state.get("target_asset_prices")
+            benchmark_data = state.get("benchmark_prices")
+            
+            if prices_data is not None:
+                if isinstance(prices_data, dict):
+                    prices = pd.Series(prices_data)
+                    prices.index = pd.to_datetime(prices.index)
+                else:
+                    prices = prices_data
+                price_source = "TARGET_ASSET"
+            else:
+                prices = kci / kci.iloc[0] * 10000
+            
+            if benchmark_data is not None:
+                if isinstance(benchmark_data, dict):
+                    benchmark_prices = pd.Series(benchmark_data)
+                    benchmark_prices.index = pd.to_datetime(benchmark_prices.index)
+                else:
+                    benchmark_prices = benchmark_data
+            else:
+                benchmark_prices = prices
+            
+            report = self.engine.run_full_backtest(kci, prices, benchmark_prices=benchmark_prices)
             
             signals = self.engine.generate_signals(kci)
             current_signal = "LONG" if len(signals) > 0 and signals.iloc[-1] == 1 else "FLAT"
             
-            return {"backtest_report": report, "current_signal": current_signal}
+            return {"backtest_report": report, "current_signal": current_signal, "price_source": price_source}
             
         except Exception as e:
             logger.error(f"Backtest Agent 에러: {e}")
